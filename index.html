<!doctype html>
<html>
<head>
<title>LEGO Pirates Treasure Hunt</title>
<style>
body {
	background: #000;
	color: #fff;
}
.top {
	display: flex;
}
.mainView {
	display: inline-block;
	flex: 0 0 450px;
	height: 450px;
	user-select: none;
}
.world {
	border-collapse: collapse;
}
.mainView.mapOpen .world {
	display: none;
}
.world > tr > td {
	height: 150px;
	padding: 0;
	width: 150px;
}
.world > tr > td > img {
	display: block;
	margin: 0;
	-webkit-user-drag: none;
}
.map {
	border-collapse: collapse;
	display: none;
}
.map > tr > td > img {
	-webkit-user-drag: none;
}
.mainView.mapOpen .map {
	display: block;
}
.map > tr > td {
	height: 32px;
	padding: 0;
	width: 32px;
}
.map > tr > td > img {
	display: block;
	margin: 0;
}
.navigable {
	cursor: pointer;
}
.sidebar {
	display: flex;
	flex-direction: column;
	width: 144px;
}
.score > img {
	height: 10px;
	vertical-align: middle;
	width: 10px;
}
.steps {
	margin-top: 16px;
}
.controls {
	align-items: flex-end;
	display: flex;
	flex: 0 0 311px;
}
.controls > img {
	cursor: pointer;
	height: 44px;
}
.items {
	align-items: flex-end;
	display: flex;
	flex: 1 0;
}
.items > img {
	height: 44px;
}
</style>
</head>
<body>

<script>
'use strict';
{
	const win = window;
	const Object = win.Object;
	const Array = win.Array;
	const Map = win.Map;
	const Set = win.Set;
	const doc = win.document;

	const RemovableItemSet = class {
		constructor() {
			this.items = new Set();
		}

		add(value) {
			const item = new RemovableItem(this, value);
			this.items.add(item);
			return item;
		}

		*[Symbol.iterator]() {
			for (let item of this.items) {
				yield item.value;
			}
		}
	};

	const RemovableItem = class {
		constructor(set, value) {
			this.set = set;
			this.value = value;
		}

		isActive() {
			return this.set != null;
		}

		stop() {
			if (this.set) {
				this.set.items.delete(this);
				this.set = null;
			}
		}
	};

	const LiveValue = class {
		constructor(value) {
			this.value = value;
			this.listeners = new RemovableItemSet();
			this.updating = false;
		}

		get() {
			return this.value;
		}

		set(newValue) {
			if (newValue !== this.value) {
				this.value = newValue;
				this.updating = true;
				for (let listener of this.listeners) {
					listener(newValue);
					if (!this.updating) {
						return;
					}
				}
				this.updating = false;
			}
		}

		listen(handler) {
			const listener = this.listeners.add(handler);
			handler(this.value);
			return listener;
		}
	};

	const Coordinates = class {
		constructor(...values) {
			this.values = values;
		}

		x() {
			return this.values[0];
		}

		y() {
			return this.values[1];
		}

		isOrigin() {
			return this.values.every((value) => value == 0);
		}

		add(coordinates) {
			return new Coordinates(...this.values.map((value, i) => {
				return value + coordinates.values[i];
			}));
		}

		static from2D(x, y) {
			return new Coordinates(x, y);
		}
	};

	const Space = class {
		constructor(from, to) {
			this.from = from;
			this.to = to;
		}

		getRelative(coordinates) {
			return new Coordinates(...coordinates.values.map((value, i) => {
				return value < this.from.values[i] ? -1 : value >= this.to.values[i] ? 1 : 0;
			}));
		}

		doesContain(coordinates) {
			return this.getRelative(coordinates).isOrigin();
		}

		getSize() {
			return new Coordinates(...this.to.values.map((toValue, i) => toValue - this.from.values[i]));
		}
	};

	const WorldMap = class {
		constructor(name, borderTiles, playerTile, tiles, start, viewRadius, backgroundColor) {
			this.name = name;
			this.borderTiles = borderTiles;
			this.playerTile = playerTile;
			this.tiles = tiles;
			this.items = [1, 2].map((n) => new LiveValue(false));
			this.start = start;
			this.viewRadius = viewRadius;
			this.backgroundColor = backgroundColor;

			this.size = new Coordinates(tiles[0].length, tiles.length);
			this.dimensions = new Space(new Coordinates(0, 0), this.size);
		}

		get(coordinates) {
			const relative = this.dimensions.getRelative(coordinates);
			if (!relative.isOrigin()) {
				return this.borderTiles[relative.y() + 1][relative.x() + 1];
			}
			return this.tiles[coordinates.y()][coordinates.x()];
		}

		update(coordinates, tile) {
			if (this.dimensions.doesContain(coordinates)) {
				this.tiles[coordinates.y()][coordinates.x()] = tile;
			}
		}

		pickup(item) {
			this.items[item].set(true);
		}
	};

	const Game = class {
		constructor(map, coordinates, score, steps) {
			this.map = map;
			this.coordinates = new LiveValue(coordinates);
			this.score = new LiveValue(score);
			this.steps = new LiveValue(steps);
			this.mapOpen = new LiveValue(false);
			this.message = new LiveValue(null);
		}

		move(offset) {
			const newCoordinates = this.coordinates.get().add(offset);
			if (!this.mapOpen.get() && this.map.get(newCoordinates).isNavigable()) {
				this.coordinates.set(newCoordinates);
				this.steps.set(this.steps.get() + 1);
				this.score.set(this.score.get() - 1);
				this.message.set(null);
				this.map.get(newCoordinates).transition(this);
			}
		}

		toggleMap() {
			const newMapOpen = !this.mapOpen.get();
			this.mapOpen.set(newMapOpen);
			if (newMapOpen) {
				this.score.set(this.score.get() - 1);
			}
			this.steps.set(this.steps.get() + 1);
		}

		addPoints(delta) {
			if (delta != 0) {
				this.message.set(`You just ${delta > 0 ? 'gained' : 'lost'} ${delta} points!`);
				this.score.set(this.score.get() + delta);
			}
		}

		updateTile(tile) {
			this.map.update(this.coordinates.get(), tile);
		}

		pickup(item) {
			this.map.pickup(item);
		}

		setMap(map, coordinates) {
			this.map = map;
			this.coordinates.set(coordinates);
		}
	};

	const createGameView = (game, doc) => {
		const view = doc.createElement('div');
		view.classList.add('game');

		const mapContainer = createWorldView(game, doc);
		view.appendChild(mapContainer);

		const scoreContainer = doc.createElement('div');
		scoreContainer.classList.add('score');
		view.appendChild(scoreContainer);
		['Left', 'Middle', 'Right'].forEach((part) => {
			const scoreBarPart = doc.createElement('img');
			scoreBarPart.src = `img/scoreBar${part}.png`;
			scoreContainer.appendChild(scoreBarPart);
		});
		const scoreBar = scoreContainer.childNodes[1];
		const scoreText = doc.createTextNode('');
		scoreContainer.appendChild(scoreText);

		game.score.listen((score) => {
			scoreBar.style.width = `${score * 10}px`;
			scoreText.nodeValue = score;
		});

		const messageContainer = doc.createElement('div');
		view.appendChild(messageContainer);

		let messageNode = null;
		game.message.listen((message) => {
			if (message == null) {
				if (messageNode) {
					messageContainer.removeChild(messageNode);
					messageNode = null;
				}
			} else {
				if (!messageNode) {
					messageNode = doc.createTextNode(message);
					messageContainer.appendChild(messageNode);
				} else {
					messageNode.nodeValue = message;
				}
			}
		});

		const stepContainer = doc.createElement('div');
		stepContainer.classList.add('steps');
		view.appendChild(stepContainer);
		stepContainer.appendChild(doc.createTextNode('Steps used: '));
		const stepText = doc.createTextNode('');
		stepContainer.appendChild(stepText);

		game.steps.listen((steps) => {
			stepText.nodeValue = steps;
		});

		return view;
	};

	const createWorldView = (game, doc) => {
		const map = game.map;

		const container = doc.createElement('div');
		container.classList.add('top');

		const mainView = doc.createElement('div');
		mainView.classList.add('mainView');
		container.appendChild(mainView);

		const worldView = doc.createElement('table');
		worldView.classList.add('world');
		worldView.style.backgroundColor = map.backgroundColor;
		mainView.appendChild(worldView);
		for (let y = -map.viewRadius; y <= map.viewRadius; y++) {
			const row = doc.createElement('tr');
			worldView.appendChild(row);
			for (let x = -map.viewRadius; x <= map.viewRadius; x++) {
				const viewCoordinates = new Coordinates(x, y);
				const cell = doc.createElement('td');
				row.appendChild(cell);
				const img = doc.createElement('img');
				cell.appendChild(img);

				const isCenter = x == 0 && y == 0;
				if (!isCenter) {
					cell.addEventListener('click', (event) => {
						game.move(viewCoordinates);
					}, false);
				}
			}
		}

		const mapView = doc.createElement('table');
		mapView.classList.add('map');
		mapView.style.backgroundColor = map.backgroundColor;
		mainView.appendChild(mapView);
		for (let y = 0; y < map.dimensions.to.y(); y++) {
			const row = doc.createElement('tr');
			mapView.appendChild(row);
			for (let x = 0; x < map.dimensions.to.x(); x++) {
				const cell = doc.createElement('td');
				row.appendChild(cell);
				const img = doc.createElement('img');
				map.get(new Coordinates(x, y)).setMapImageUrl(img);
				cell.appendChild(img);
			}
		}

		game.mapOpen.listen((mapOpen) => {
			mainView.classList.toggle('mapOpen', mapOpen);
		});

		let mapPlayerCoordinates = null;
		game.coordinates.listen((coordinates) => {
			Array.prototype.forEach.call(worldView.childNodes, (row, y) => {
				Array.prototype.forEach.call(row.childNodes, (cell, x) => {
					const relative = new Coordinates(x - map.viewRadius, y - map.viewRadius);
					const img = cell.firstChild;
					if (relative.isOrigin()) {
						map.playerTile.setWorldImageUrl(img);
					} else {
						const tileCoordinates = coordinates.add(relative);
						const tile = map.get(tileCoordinates);
						const img = cell.firstChild;
						tile.setWorldImageUrl(img);
						cell.classList.toggle('navigable', tile.isNavigable());
					}
				});
			});

			if (mapPlayerCoordinates) {
				map.get(mapPlayerCoordinates).setMapImageUrl(mapView.childNodes[mapPlayerCoordinates.y()].childNodes[mapPlayerCoordinates.x()].firstChild);
			}
			mapPlayerCoordinates = coordinates;
			map.playerTile.setMapImageUrl(mapView.childNodes[coordinates.y()].childNodes[coordinates.x()].firstChild);
		});

		const sidebar = doc.createElement('div');
		sidebar.classList.add('sidebar');
		container.appendChild(sidebar);

		const controlContainer = doc.createElement('div');
		controlContainer.classList.add('controls');
		sidebar.appendChild(controlContainer);

		const saveControl = doc.createElement('img');
		saveControl.src = 'img/save.png';
		controlContainer.appendChild(saveControl);

		const mapControl = doc.createElement('img');
		mapControl.src = 'img/map.png';
		controlContainer.appendChild(mapControl);
		mapControl.addEventListener('click', (event) => {
			game.toggleMap();
		}, false);

		const itemContainer = doc.createElement('div');
		itemContainer.classList.add('items');
		sidebar.appendChild(itemContainer);

		map.items.forEach((item, n) => {
			const itemSlot = doc.createElement('img');
			itemContainer.appendChild(itemSlot);
			item.listen((item) => {
				if (item) {
					itemSlot.src = `${map.name}/items/item${n + 1}.png`;
				} else {
					itemSlot.removeAttribute('src');
				}
			});
		});

		return container;
	};

	const rToTile = new Map();
	const Tile = class {
		constructor(mapType, worldType, transition) {
			this.mapType = mapType;
			this.worldType = worldType;
			this.transition = transition;
		}

		isNavigable() {
			return this.transition != Tile.IMPASSIBLE;
		}

		setMapImageUrl(img) {
			Tile.setImageUrl(img, this.mapType && `sea/map/${this.mapType}.png`);
		}

		setWorldImageUrl(img) {
			Tile.setImageUrl(img, this.worldType && `sea/world/${this.worldType}.png`);
		}

		static setImageUrl(img, src) {
			if (src == null) {
				img.removeAttribute('src');
			} else {
				img.src = src;
			}
		}
	};
	Tile.IMPASSIBLE = null;
	Tile.NOOP = (game) => {};

	const TILES = {
		PLAYER: new Tile('player', 'player', Tile.IMPASSIBLE), // Row Boat, Foot
		TERRAIN_1: new Tile(null, 'terrain1', Tile.NOOP), // Water, Sand
		TERRAIN_2: new Tile(null, 'terrain2', Tile.NOOP), // Wave, Dune
		OBSTACLE_1: new Tile('obstacle', 'obstacle1', Tile.IMPASSIBLE), // Rock, 
		OBSTACLE_2: new Tile('obstacle', 'obstacle2', Tile.IMPASSIBLE), // Monkey Island, 
		OBSTACLE_3: new Tile('obstacle', 'obstacle3', Tile.IMPASSIBLE), // Crocodile Island, 
		OBSTACLE_4: new Tile('obstacle', 'obstacle4', Tile.IMPASSIBLE), // Figure Island, 
		OBSTACLE_5: new Tile('obstacle', 'obstacle5', Tile.IMPASSIBLE), // Sinkin Boat, 
		OBSTACLE_TOP_LEFT: new Tile(null, 'obstacleTopLeft', Tile.IMPASSIBLE), // Island Top Left, 
		OBSTACLE_TOP_MIDDLE: new Tile(null, 'obstacleTop', Tile.IMPASSIBLE), // Island Top Middle, 
		OBSTACLE_TOP_RIGHT: new Tile(null, 'obstacleTopRight', Tile.IMPASSIBLE), // Island Top Right, 
		OBSTACLE_MIDDLE_LEFT: new Tile(null, 'obstacleLeft', Tile.IMPASSIBLE), // Island Middle Left, 
		OBSTACLE_BOTTOM_LEFT: new Tile(null, 'obstacleBottomLeft', Tile.IMPASSIBLE), // Island Bottom Left, 
		TREASURE_1: new Tile('treasure', 'treasure1', (game) => { game.addPoints(4); game.updateTile(TILES.TREASURE_1_EMPTY); }), // Closed Chest, 
		TREASURE_2: new Tile('treasure', 'treasure2', (game) => { game.addPoints(4); game.updateTile(TILES.TREASURE_2_EMPTY); }), // Open Gold Chest,
		TREASURE_3: new Tile('treasure', 'treasure3', (game) => { game.addPoints(4); game.updateTile(TILES.TREASURE_3_EMPTY); }), // Gold Barrel, 
		TREASURE_4: new Tile('treasure', 'treasure4', (game) => { game.addPoints(4); game.updateTile(TILES.TREASURE_4_EMPTY); }), // Shipwreck, 
		TREASURE_1_EMPTY: new Tile('treasure', 'treasure1Empty', Tile.NOOP), // Closed Chest, 
		TREASURE_2_EMPTY: new Tile('treasure', 'treasure2Empty', Tile.NOOP), // Open Gold Chest,
		TREASURE_3_EMPTY: new Tile('treasure', 'treasure3Empty', Tile.NOOP), // Gold Barrel, 
		TREASURE_4_EMPTY: new Tile('treasure', 'treasure4Empty', Tile.NOOP), // Shipwreck, 
		ITEM_1: new Tile('item1', 'item1', (game) => { game.updateTile(TILES.ITEM_1_EMPTY); game.pickup(0); }), // Bottle, 
		ITEM_2: new Tile('item2', 'item2', (game) => { game.updateTile(TILES.ITEM_2_EMPTY); game.pickup(1); }), // Shovel, 
		ITEM_1_EMPTY: new Tile('item1', 'item1Empty', Tile.NOOP), // Water, 
		ITEM_2_EMPTY: new Tile('item2', 'item2Empty', Tile.NOOP), // Raft, 
		GOAL: new Tile('goal', 'goal', (game) => { }), // Treasure Island, 
		ENEMY_1: new Tile(null, 'enemy1', (game) => { game.addPoints(-6); }), // Octopus, 
		ENEMY_2: new Tile(null, 'enemy2', (game) => { game.addPoints(-6); }), // Shark Head, 
		ENEMY_3: new Tile(null, 'enemy3', (game) => { game.addPoints(-6); }), // Pirate, 
		ENEMY_4: new Tile(null, 'enemy4', (game) => { game.addPoints(-6); }), // Soldier, 
		ENEMY_5: new Tile(null, 'enemy5', (game) => { game.addPoints(-6); }), // Cannon, 
		ENEMY_6: new Tile(null, 'enemy6', (game) => { game.addPoints(-6); }), // Shark Fin, 
		ENEMY_7: new Tile(null, 'enemy7', (game) => { game.addPoints(-6); }), // Skeleton, 
	};

	const BORDER_TILES = ['Top', '', 'Bottom'].map((vertical) => {
		return ['Left', '', 'Right'].map((horizontal) => {
			if (vertical == '' && horizontal == '') {
				return null;
			}
			return new Tile(null, 'border' + vertical + horizontal, Tile.IMPASSIBLE);
		});
	});

	let game;
	{
		const rMaps = [
			['sea', 1, '#039', [
				'.          .  ',
				'    # #       ',
				' # .  #       ',
				'  #    #B  . T',
				'        #     ',
				' C~  #   .#.  ',
				'~~ #~~+~!~    ',
				' ~O /~~C ~C # ',
				'  ~#  $~~ $   ',
				' O~,~.~ CS &  ',
				'~~$~O C~~O~   ',
				'. #~~~~*  #  .',
				'~O ~~@  ~~~%  ',
				'  ~~qnp ~O~   ',
			]],
			['land', 1, '#fc6', [
				'.          .  ',
				'    # #       ',
				' # .  #       ',
				'  #    #B  . T',
				'        #     ',
				' C~  #   .#.  ',
				'~~ #~~+~!~    ',
				' ~O /~~C ~C # ',
				'  ~#  $~~ $   ',
				' O~,~.~ CS &  ',
				'~~$~O C~~O~   ',
				'. #~~~~*  #  .',
				'~O ~~@  ~~~%  ',
				'  ~~qnp ~O~   ',
			]],
		];

		const TILES_BY_R = new Map([
			['@', TILES.TERRAIN_1],
			[' ', TILES.TERRAIN_1],
			['~', TILES.TERRAIN_2],
			['#', TILES.OBSTACLE_1],
			['O', TILES.OBSTACLE_2],
			['C', TILES.OBSTACLE_3],
			['q', TILES.OBSTACLE_TOP_LEFT],
			['n', TILES.OBSTACLE_TOP_MIDDLE],
			['p', TILES.OBSTACLE_TOP_RIGHT],
			['<', TILES.OBSTACLE_MIDDLE_LEFT],
			['L', TILES.OBSTACLE_BOTTOM_LEFT],
			['.', TILES.TREASURE_1],
			['!', TILES.TREASURE_2],
			['$', TILES.TREASURE_3],
			['+', TILES.TREASURE_4],
			['S', TILES.ITEM_1],
			['B', TILES.ITEM_2],
			['T', TILES.GOAL],
			['*', TILES.ENEMY_1],
			[',', TILES.ENEMY_2],
			['%', TILES.ENEMY_3],
			['/', TILES.ENEMY_4],
			['&', TILES.ENEMY_5],
		]);

		const maps = new Map();
		rMaps.forEach((rMap, i) => {
			const [name, viewRadius, backgroundColor, rTiles] = rMap;
			const tiles = [];
			let start = new Coordinates(0, 0);

			const height = rTiles.length;
			const width = rTiles[0].length;

			rTiles.forEach((rRow, rY) => {
				const row = [];
				tiles.push(row);
				rRow.split('').forEach((rTile, rX) => {
					if (rTile == '@') {
						start = new Coordinates(rX, rY);
					}
					row.push(TILES_BY_R.get(rTile));
				});
			});

			const map = new WorldMap(name, BORDER_TILES, TILES.PLAYER, tiles, start, viewRadius, backgroundColor);
			maps.set(name, map);
			if (i == 0) {
				game = new Game(map, map.start, 19, 1);
			}
		});
	}

	doc.body.appendChild(createGameView(game, doc));
}
</script>
</body>
</html>
