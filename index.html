<!doctype html>
<html>
<head>
<title>LEGO Pirates Treasure Hunt</title>
<style>
body {
	background: #000;
	color: #fff;
}
.mainView {
	display: inline-block;
	height: 450px;
	width: 450px;
}
.world {
	border-collapse: collapse;
	user-select: none;
}
.mainView.mapOpen .world {
	display: none;
}
.world > tr > td {
	height: 150px;
	padding: 0;
	width: 150px;
}
.world > tr > td > img {
	display: block;
	margin: 0;
	-webkit-user-drag: none;
}
.sea > .world, .sea > .map {
	background: #039;
}
.land > .world, .land > .map {
	background: #fc6;
}
.map {
	border-collapse: collapse;
	display: none;
}
.mainView.mapOpen .map {
	display: block;
}
.map > tr > td {
	height: 32px;
	padding: 0;
	width: 32px;
}
.map > tr > td > img {
	display: block;
	margin: 0;
}
.navigable {
	cursor: pointer;
}
.score > img {
	height: 10px;
	vertical-align: middle;
	width: 10px;
}
.controls {
	display: inline-block;
	padding-top: 267px;;
	vertical-align: top;
}
.controls img {
	cursor: pointer;
}
</style>
</head>
<body>

<script>
'use strict';
{
	const win = window;
	const Object = win.Object;
	const Array = win.Array;
	const Map = win.Map;
	const Set = win.Set;
	const doc = win.document;

	const RemovableItemSet = class {
		constructor() {
			this.items = new Set();
		}

		add(value) {
			const item = new RemovableItem(this, value);
			this.items.add(item);
			return item;
		}

		*[Symbol.iterator]() {
			for (let item of this.items) {
				yield item.value;
			}
		}
	};

	const RemovableItem = class {
		constructor(set, value) {
			this.set = set;
			this.value = value;
		}

		isActive() {
			return this.set != null;
		}

		stop() {
			if (this.set) {
				this.set.items.delete(this);
				this.set = null;
			}
		}
	};

	const LiveValue = class {
		constructor(value) {
			this.value = value;
			this.listeners = new RemovableItemSet();
			this.updating = false;
		}

		get() {
			return this.value;
		}

		set(newValue) {
			if (newValue !== this.value) {
				this.value = newValue;
				this.updating = true;
				for (let listener of this.listeners) {
					listener(newValue);
					if (!this.updating) {
						return;
					}
				}
				this.updating = false;
			}
		}

		listen(handler) {
			const listener = this.listeners.add(handler);
			handler(this.value);
			return listener;
		}
	};

	const Coordinates = class {
		constructor(...values) {
			this.values = values;
		}

		x() {
			return this.values[0];
		}

		y() {
			return this.values[1];
		}

		isOrigin() {
			return this.values.every((value) => value == 0);
		}

		add(coordinates) {
			return new Coordinates(...this.values.map((value, i) => {
				return value + coordinates.values[i];
			}));
		}

		static from2D(x, y) {
			return new Coordinates(x, y);
		}
	};

	const Space = class {
		constructor(from, to) {
			this.from = from;
			this.to = to;
		}

		getRelative(coordinates) {
			return new Coordinates(...coordinates.values.map((value, i) => {
				return value < this.from.values[i] ? -1 : value >= this.to.values[i] ? 1 : 0;
			}));
		}

		doesContain(coordinates) {
			return this.getRelative(coordinates).isOrigin();
		}

		getSize() {
			return new Coordinates(...this.to.values.map((toValue, i) => toValue - this.from.values[i]));
		}
	};

	const WorldMap = class {
		constructor(name, borderTiles, playerTile, tiles, start, viewRadius) {
			this.name = name;
			this.borderTiles = borderTiles;
			this.playerTile = playerTile;
			this.tiles = tiles;
			this.start = start;
			this.viewRadius = viewRadius;

			const height = tiles.length;
			const width = tiles[0].length;
			this.size = new Coordinates(width, height);
			this.dimensions = new Space(new Coordinates(0, 0), this.size);
		}

		get(coordinates) {
			const relative = this.dimensions.getRelative(coordinates);
			if (!relative.isOrigin()) {
				return this.borderTiles[relative.y() + 1][relative.x() + 1];
			}
			return this.tiles[coordinates.y()][coordinates.x()];
		}
	};

	const Game = class {
		constructor(map, coordinates, score, steps, doc, parent) {
			this.map = map;
			this.coordinates = new LiveValue(coordinates);
			this.score = new LiveValue(score);
			this.steps = new LiveValue(steps);
			this.mapOpen = new LiveValue(false);
			// UI
			this.doc = doc;
			this.parent = parent;
			this.view = null;
			this.mapPlayerCoordinates = null;
		}

		move(offset) {
			const newCoordinates = this.coordinates.get().add(offset);
			if (!this.mapOpen.get() && this.map.get(newCoordinates).isNavigable()) {
				this.moveTo(newCoordinates);
			}
		}

		toggleMap() {
			const newMapOpen = !this.mapOpen.get();
			this.mapOpen.set(newMapOpen);
			if (newMapOpen) {
				this.score.set(this.score.get() - 1);
			}
			this.steps.set(this.steps.get() + 1);
		}

		moveTo(newCoordinates) {
			this.coordinates.set(newCoordinates);
			this.steps.set(this.steps.get() + 1);
			this.score.set(this.score.get() - 1);
		}

		setMap(map, coordinates) {
			this.map = map;
			this.coordinates.set(coordinates);
		}
	};

	const createGameView = (game, doc) => {
		const view = doc.createElement('div');
		view.classList.add('game');

		const mapContainer = createWorldView(game, doc);
		view.appendChild(mapContainer);

		const controlContainer = doc.createElement('div');
		controlContainer.classList.add('controls');
		view.appendChild(controlContainer);

		const saveControl = doc.createElement('img');
		saveControl.src = 'img/save.png';
		controlContainer.appendChild(saveControl);

		const mapControl = doc.createElement('img');
		mapControl.src = 'img/map.png';
		controlContainer.appendChild(mapControl);
		mapControl.addEventListener('click', (event) => {
			game.toggleMap();
		}, false);

		const scoreContainer = doc.createElement('div');
		scoreContainer.classList.add('score');
		view.appendChild(scoreContainer);
		['Left', 'Middle', 'Right'].forEach((part) => {
			const scoreBarPart = doc.createElement('img');
			scoreBarPart.src = `img/scoreBar${ part }.png`;
			scoreContainer.appendChild(scoreBarPart);
		});
		const scoreBar = scoreContainer.childNodes[1];
		const scoreText = doc.createTextNode('');
		scoreContainer.appendChild(scoreText);

		game.score.listen((score) => {
			scoreBar.style.width = `${ score * 10 }px`;
			scoreText.nodeValue = score;
		});

		const stepContainer = doc.createElement('div');
		view.appendChild(stepContainer);
		stepContainer.appendChild(doc.createTextNode('Steps used: '));
		const stepText = doc.createTextNode('');
		stepContainer.appendChild(stepText);

		game.steps.listen((steps) => {
			stepText.nodeValue = steps;
		});

		return view;
	};

	const createWorldView = (game, doc) => {
		const map = game.map;

		const container = doc.createElement('div');
		container.classList.add('mainView', map.name);
		const worldView = doc.createElement('table');
		worldView.classList.add('world');
		container.appendChild(worldView);
		for (let y = -map.viewRadius; y <= map.viewRadius; y++) {
			const row = doc.createElement('tr');
			worldView.appendChild(row);
			for (let x = -map.viewRadius; x <= map.viewRadius; x++) {
				const viewCoordinates = new Coordinates(x, y);
				const cell = doc.createElement('td');
				row.appendChild(cell);
				const img = doc.createElement('img');
				cell.appendChild(img);

				const isCenter = x == 0 && y == 0;
				if (!isCenter) {
					cell.addEventListener('click', (event) => {
						game.move(viewCoordinates);
					}, false);
				}
			}
		}

		const mapView = doc.createElement('table');
		mapView.classList.add('map');
		container.appendChild(mapView);
		for (let y = 0; y < map.dimensions.to.y(); y++) {
			const row = doc.createElement('tr');
			mapView.appendChild(row);
			for (let x = 0; x < map.dimensions.to.x(); x++) {
				const cell = doc.createElement('td');
				row.appendChild(cell);
				const img = doc.createElement('img');
				map.get(new Coordinates(x, y)).setMapImageUrl(img);
				cell.appendChild(img);
			}
		}

		game.mapOpen.listen((mapOpen) => {
			container.classList.toggle('mapOpen', mapOpen);
		});

		let mapPlayerCoordinates = null;
		game.coordinates.listen((coordinates) => {
			Array.prototype.forEach.call(worldView.childNodes, (row, y) => {
				Array.prototype.forEach.call(row.childNodes, (cell, x) => {
					const relative = new Coordinates(x - map.viewRadius, y - map.viewRadius);
					const img = cell.firstChild;
					if (relative.isOrigin()) {
						map.playerTile.setWorldImageUrl(img);
					} else {
						const tileCoordinates = coordinates.add(relative);
						const tile = map.get(tileCoordinates);
						const img = cell.firstChild;
						tile.setWorldImageUrl(img);
						cell.classList.toggle('navigable', tile.isNavigable());
					}
				});
			});

			if (mapPlayerCoordinates) {
				map.get(mapPlayerCoordinates).setMapImageUrl(mapView.childNodes[mapPlayerCoordinates.y()].childNodes[mapPlayerCoordinates.x()].firstChild);
			}
			mapPlayerCoordinates = coordinates;
			map.playerTile.setMapImageUrl(mapView.childNodes[coordinates.y()].childNodes[coordinates.x()].firstChild);
		});

		return container;
	};

	const rToTile = new Map();
	const Tile = class {
		constructor(mapType, worldType, transition) {
			this.mapType = mapType;
			this.worldType = worldType;
			this.transition = transition;
		}

		isNavigable() {
			return this.transition != Tile.IMPASSIBLE;
		}

		setMapImageUrl(img) {
			Tile.setImageUrl(img, this.mapType && `sea/map/${ this.mapType }.png`);
		}

		setWorldImageUrl(img) {
			Tile.setImageUrl(img, this.worldType && `sea/world/${ this.worldType }.png`);
		}

		static setImageUrl(img, src) {
			if (src == null) {
				img.removeAttribute('src');
			} else {
				img.src = src;
			}
		}
	};
	Tile.IMPASSIBLE = null;
	Tile.NOOP = (score, items) => {};
	const TILES = {
		PLAYER: new Tile('player', 'player', null),
		borders: ['Top', '', 'Bottom'].map((vertical) => {
			return ['Left', '', 'Right'].map((horizontal) => {
				if (vertical == '' && horizontal == '') {
					return null;
				}
				return new Tile(null, 'border' + vertical + horizontal, Tile.IMPASSIBLE);
			});
		}),
		byR: new Map(),
	};

	{
		const rTiles = {
			' ': [null, null, Tile.NOOP], // Ocean, Sand
			'~': [null, 'surface2', Tile.NOOP], // Wave, Dune
			'#': ['obstacle', 'obstacle1', Tile.IMPASSIBLE], // Rock, 
			'O': ['obstacle', 'obstacle2', Tile.IMPASSIBLE], // Monkey Island, 
			'C': ['obstacle', 'obstacle3', Tile.IMPASSIBLE], // Crocodile Island, 
			'q': [null, 'obstacleTopLeft', Tile.IMPASSIBLE], // Island Top Left, 
			'n': [null, 'obstacleTop', Tile.IMPASSIBLE], // Island Top Middle, 
			'p': [null, 'obstacleTopRight', Tile.IMPASSIBLE], // Island Top Right, 
			'<': [null, 'obstacleLeft', Tile.IMPASSIBLE], // Island Left Middle, 
			'L': [null, 'obstacleBottomLeft', Tile.IMPASSIBLE], // Island Bottom Left, 
			'.': ['treasure', 'treasure1', (score, items) => { score += 4; }], // Closed Chest, 
			'!': ['treasure', 'treasure2', Tile.NOOP], // Open Gold Chest,
			'$': ['treasure', 'treasure3', (score, items) => { score += 7; }], // Gold Barrel, 
			'+': ['treasure', 'treasure4', Tile.NOOP], // Shipwreck, 
			'B': ['item1', 'item1', Tile.NOOP], // Bottle, 
			'S': ['item2', 'item2', Tile.NOOP], // Shovel, 
			'T': ['goal', 'goal', []], // Treasure Island, 
			'*': [null, 'enemy1', (score, items) => { score -= 6; }], // Octopus, 
			',': [null, 'enemy2', (score, items) => { score -= 6; }], // Shark Head, 
			'%': [null, 'enemy3', (score, items) => { score -= 6; }], // Pirate, 
			'/': [null, 'enemy4', (score, items) => { score -= 6; }], // Soldier, 
			'&': [null, 'enemy5', (score, items) => { score -= 6; }], // Cannon, 
		};

		{
			Object.keys(rTiles).forEach((rSymbol) => {
				const [mapType, worldType, transition] = rTiles[rSymbol];
				TILES.byR.set(rSymbol, new Tile(mapType, worldType, transition));
			});
		}
	}

	let game;
	{
		const rMaps = [
			['sea', 1, '#039', [
				'.          .  ',
				'    # #       ',
				' # .  #       ',
				'  #    #B  . T',
				'        #     ',
				' C~  #   .#.  ',
				'~~ #~~+~!~    ',
				' ~O /~~C ~C # ',
				'  ~#  $~~ $   ',
				' O~,~.~ CS &  ',
				'~~$~O C~~O~   ',
				'. #~~~~*  #  .',
				'~O ~~@  ~~~%  ',
				'  ~~qnp ~O~   ',
			]],
			['land', 1, '#fc6', [
				'.          .  ',
				'    # #       ',
				' # .  #       ',
				'  #    #B  . T',
				'        #     ',
				' C~  #   .#.  ',
				'~~ #~~+~!~    ',
				' ~O /~~C ~C # ',
				'  ~#  $~~ $   ',
				' O~,~.~ CS &  ',
				'~~$~O C~~O~   ',
				'. #~~~~*  #  .',
				'~O ~~@  ~~~%  ',
				'  ~~qnp ~O~   ',
			]],
		];

		const maps = new Map();
		rMaps.forEach((rMap, i) => {
			const [name, viewRadius, color, rTiles] = rMap;
			const tiles = [];
			let start = new Coordinates(0, 0);

			const height = rTiles.length;
			const width = rTiles[0].length;

			rTiles.forEach((rRow, rY) => {
				const row = [];
				tiles.push(row);
				rRow.split('').forEach((rTile, rX) => {
					if (rTile == '@') {
						start = new Coordinates(rX, rY);
						rTile = ' ';
					}
					row.push(TILES.byR.get(rTile));
				});
			});

			const map = new WorldMap(name, TILES.borders, TILES.PLAYER, tiles, start, viewRadius);
			maps.set(name, map);
			if (i == 0) {
				game = new Game(map, map.start, 19, 1, doc, doc.body);
			}
		});
	}

	doc.body.appendChild(createGameView(game, doc));
}
</script>
</body>
</html>
